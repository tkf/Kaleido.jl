<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Kaleido.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Kaleido.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Setting/getting-multiple-locations"><span>Setting/getting multiple locations</span></a></li><li><a class="tocitem" href="#Bijective-transformations-as-lenses"><span>Bijective transformations as lenses</span></a></li><li><a class="tocitem" href="#Misc-lenses"><span>Misc lenses</span></a></li><li><a class="tocitem" href="#Setters"><span>Setters</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tkf/Kaleido.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Kaleido.jl"><a class="docs-heading-anchor" href="#Kaleido.jl">Kaleido.jl</a><a id="Kaleido.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Kaleido.jl" title="Permalink"></a></h1><ul><li><a href="#Kaleido"><code>Kaleido</code></a></li><li><a href="#Kaleido.nullsetter"><code>Kaleido.nullsetter</code></a></li><li><a href="#Kaleido.settingasℝ₊"><code>Kaleido.settingasℝ₊</code></a></li><li><a href="#Kaleido.settingasℝ₋"><code>Kaleido.settingasℝ₋</code></a></li><li><a href="#Kaleido.settingas𝕀"><code>Kaleido.settingas𝕀</code></a></li><li><a href="#Kaleido.FLens"><code>Kaleido.FLens</code></a></li><li><a href="#Kaleido.FlatLens"><code>Kaleido.FlatLens</code></a></li><li><a href="#Kaleido.IndexBatchLens"><code>Kaleido.IndexBatchLens</code></a></li><li><a href="#Kaleido.KeyBatchLens"><code>Kaleido.KeyBatchLens</code></a></li><li><a href="#Kaleido.MultiLens"><code>Kaleido.MultiLens</code></a></li><li><a href="#Kaleido.PropertyBatchLens"><code>Kaleido.PropertyBatchLens</code></a></li><li><a href="#Kaleido.ToField"><code>Kaleido.ToField</code></a></li><li><a href="#Kaleido.batch"><code>Kaleido.batch</code></a></li><li><a href="#Kaleido.constraining"><code>Kaleido.constraining</code></a></li><li><a href="#Kaleido.converting"><code>Kaleido.converting</code></a></li><li><a href="#Kaleido.getting-Tuple{Any}"><code>Kaleido.getting</code></a></li><li><a href="#Kaleido.getting"><code>Kaleido.getting</code></a></li><li><a href="#Kaleido.prettylens"><code>Kaleido.prettylens</code></a></li><li><a href="#Kaleido.setting"><code>Kaleido.setting</code></a></li><li><a href="#Kaleido.@batchlens"><code>Kaleido.@batchlens</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Kaleido" href="#Kaleido"><code>Kaleido</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Kaleido: some useful lenses</strong></p><p><a href="https://tkf.github.io/Kaleido.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://tkf.github.io/Kaleido.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/tkf/Kaleido.jl/actions?query=workflow%3ARun+tests"><img src="https://github.com/tkf/Kaleido.jl/workflows/Run%20tests/badge.svg" alt="GitHub Actions"/></a> <a href="https://codecov.io/gh/tkf/Kaleido.jl"><img src="https://codecov.io/gh/tkf/Kaleido.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://coveralls.io/github/tkf/Kaleido.jl?branch=master"><img src="https://coveralls.io/repos/github/tkf/Kaleido.jl/badge.svg?branch=master" alt="Coveralls"/></a> <a href="https://github.com/tkf/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua QA"/></a> <a href="https://github.com/tkf/Kaleido.jl"><img src="https://img.shields.io/github/commits-since/tkf/Kaleido.jl/v0.2.6.svg?style=social&amp;logo=github" alt="GitHub commits since tagged version"/></a></p><p>Kaleido.jl is a collection of useful <a href="https://jw3126.github.io/Setfield.jl/latest/index.html#Setfield.Lens"><code>Lens</code></a>es and helper functions/macros built on top of <a href="https://github.com/jw3126/Setfield.jl">Setfield.jl</a>.</p><p><strong>Features</strong></p><p><strong>Summary</strong></p><ul><li>Batched/multi-valued update.  See <code>@batchlens</code>, <code>MultiLens</code>.</li><li>Get/set multiple and nested fields as a <code>StaticArray</code> or any arbitrary multi-valued container.  See <code>getting</code>.</li><li>Get/set fields with different parametrizations. See <code>converting</code>, <code>setting</code>, <code>getting</code>.</li><li>Computing other fields during <code>set</code> and <code>get</code>; i.e., adding constraints between fields.  See <code>constraining</code>.</li><li>Get/set dynamically computed locations.  See <code>FLens</code>.</li></ul><p><strong>Batched/multi-valued update</strong></p><p>Macro <code>@batchlens</code> can be used to update various nested locations in a complex immutable object:</p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; lens_batch = @batchlens begin
           _.a.b.c
           _.a.b.d[1]
           _.a.b.d[3] ∘ settingas𝕀
           _.a.e
       end;

julia&gt; obj = (a = (b = (c = 1, d = (2, 3, 0.5)), e = 5),);

julia&gt; get(obj, lens_batch)
(1, 2, 0.0, 5)

julia&gt; set(obj, lens_batch, (10, 20, Inf, 50))
(a = (b = (c = 10, d = (20, 3, 1.0)), e = 50),)</code></pre><p>(See below for what <code>settingas𝕀</code> does.)</p><p><strong>Get/set multiple and nested fields as a <code>StaticArray</code></strong></p><p>It is often useful to get the values of the fields as a vector (e.g., when optimizing a composite object with Optim.jl).  This can be done with <code>getting(f)</code> where <code>f</code> is a constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; using StaticArrays

julia&gt; lens_vec = lens_batch ∘ getting(SVector);

julia&gt; @assert get(obj, lens_vec) === SVector(1, 2, 0.0, 5)

julia&gt; set(obj, lens_vec, SVector(10, 20, Inf, 50))
(a = (b = (c = 10.0, d = (20.0, 3, 1.0)), e = 50.0),)</code></pre><p><strong>Get/set fields with different parametrizations</strong></p><p>Kaleido.jl comes with lenses <code>settingasℝ₊</code>, <code>settingasℝ₋</code>, and <code>settingas𝕀</code> to manipulating fields that have to be restricted to be positive, negative, and in <code>[0, 1]</code> interval, respectively.  Similarly there are lenses <code>gettingasℝ₊</code>, <code>gettingasℝ₋</code>, and <code>gettingas𝕀</code> to get values in those domains.  The naming is borrowed from <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; lens = (@lens _.x) ∘ settingasℝ₊;

julia&gt; get((x=1.0,), lens)  # log(1.0)
0.0

julia&gt; set((x=1.0,), lens, -Inf)
(x = 0.0,)</code></pre><p>Kaleido.jl also works with <code>AbstractTransform</code> defined in <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using TransformVariables

julia&gt; lens = (@lens _.y[2]) ∘ setting(as𝕀);

julia&gt; obj = (x=0, y=(1, 0.5, 3));

julia&gt; get(obj, lens)
0.0

julia&gt; @assert set(obj, lens, Inf).y[2] ≈ 1</code></pre><p>It also is quite easy to define ad-hoc converting accessors using <code>converting</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; lens = (@lens _.y[2]) ∘
           converting(fromfield=x -&gt; parse(Int, x), tofield=string);

julia&gt; obj = (x=0, y=(1, &quot;5&quot;, 3));

julia&gt; get(obj, lens)
5

julia&gt; set(obj, lens, 1)
(x = 0, y = (1, &quot;1&quot;, 3))</code></pre><p><strong>Computing other fields during <code>set</code> and <code>get</code></strong></p><p>It is easy to add constraints between fields using <code>constraining</code>. For example, you can impose that field <code>.c</code> must be a sum of <code>.a</code> and <code>.b</code> by:</p><pre><code class="language-julia-repl hljs">julia&gt; obj = (a = 1, b = 2, c = 3);

julia&gt; constraint = constraining() do obj
           @set obj.c = obj.a + obj.b
       end;

julia&gt; lens = constraint ∘ MultiLens((
           (@lens _.a),
           (@lens _.b),
       ));

julia&gt; get(obj, lens)
(1, 2)

julia&gt; set(obj, lens, (100, 20))
(a = 100, b = 20, c = 120)</code></pre><p>Notice that <code>.c</code> is updated as well in the last line.</p><p><strong>Get/set dynamically computed locations</strong></p><p>You can use <code>FLens</code> to <code>get</code> and <code>set</code>, e.g., the last entry of a linked list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/Kaleido.jl#LL4-L158">source</a></section></article><h2 id="Setting/getting-multiple-locations"><a class="docs-heading-anchor" href="#Setting/getting-multiple-locations">Setting/getting multiple locations</a><a id="Setting/getting-multiple-locations-1"></a><a class="docs-heading-anchor-permalink" href="#Setting/getting-multiple-locations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Kaleido.@batchlens" href="#Kaleido.@batchlens"><code>Kaleido.@batchlens</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@batchlens begin
    lens_expression_1
    lens_expression_2
    ...
    lens_expression_n
end</code></pre><p>From <span>$n$</span> &quot;lens expression&quot;, create a lens that gets/sets <span>$n$</span>-tuple. Each &quot;lens expression&quot; is an expression that is supported by <code>Setfield.@lens</code> or such expression post-composed with other lenses using <code>∘</code>.</p><p>See also <a href="#Kaleido.batch"><code>batch</code></a> which does all the heavy lifting of the transformation of the lenses.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield

julia&gt; lens = @batchlens begin
           _.a.b.c
           _.a.b.d ∘ converting(fromfield = x -&gt; parse(Int, x), tofield = string)
           _.a.e
       end;

julia&gt; obj = (a = (b = (c = 1, d = &quot;2&quot;), e = 3),);

julia&gt; get(obj, lens)
(1, 2, 3)

julia&gt; set(obj, lens, (10, 20, 30))
(a = (b = (c = 10, d = &quot;20&quot;), e = 30),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/batching.jl#LL75-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.batch" href="#Kaleido.batch"><code>Kaleido.batch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batch(lens₁, lens₂, ..., lensₙ) :: Lens</code></pre><p>From <span>$n$</span> lenses, create a single lens that gets/sets <span>$n$</span>-tuple in such a way that the number of call to the constructor is minimized. This is done by calling <a href="#Kaleido.IndexBatchLens"><code>IndexBatchLens</code></a> whenever possible.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield

julia&gt; lens = @batchlens begin
           _.a.b.c
           _.a.b.d
           _.a.e
       end;

julia&gt; @assert lens ==
           IndexBatchLens(:a) ∘ MultiLens((
               (@lens _[1]) ∘ IndexBatchLens(:b, :e) ∘ MultiLens((
                   (@lens _[1]) ∘ IndexBatchLens(:c, :d),
                   (@lens _[2]) ∘ Kaleido.SingletonLens(),
               )) ∘ FlatLens(2, 1),
           )) ∘ FlatLens(3)

julia&gt; obj = (a=(b=(c=1, d=2), e=3),);

julia&gt; get(obj, lens)
(1, 2, 3)

julia&gt; set(obj, lens, (10, 20, 30))
(a = (b = (c = 10, d = 20), e = 30),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/batching.jl#LL1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.MultiLens" href="#Kaleido.MultiLens"><code>Kaleido.MultiLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiLens([castout,] lenses::Tuple)
MultiLens([castout,] lenses::NamedTuple)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; ml = MultiLens((
           (@lens _.x),
           (@lens _.y.z),
       ))
〈◻.x, ◻.y.z〉

julia&gt; get((x=1, y=(z=2,)), ml)
(1, 2)

julia&gt; set((x=1, y=(z=2,)), ml, (&quot;x&quot;, &quot;y.z&quot;))
(x = &quot;x&quot;, y = (z = &quot;y.z&quot;,))

julia&gt; ml = MultiLens((
           a = (@lens _.x),
           b = (@lens _.y.z),
       ))
〈◻.x, ◻.y.z〉

julia&gt; get((x=1, y=(z=2,)), ml)
(a = 1, b = 2)

julia&gt; set((x=1, y=(z=2,)), ml, (a=:x, b=&quot;y.z&quot;))
(x = :x, y = (z = &quot;y.z&quot;,))

julia&gt; set((x=1, y=(z=2,)), ml, (b=&quot;y.z&quot;, a=:x))
(x = :x, y = (z = &quot;y.z&quot;,))

julia&gt; using StaticArrays

julia&gt; ml = MultiLens(
           SVector,
           (
               (@lens _.x),
               (@lens _.y.z),
           )
       )
〈◻.x, ◻.y.z〉

julia&gt; @assert get((x=1, y=(z=2,)), ml) === SVector(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/multilens.jl#LL1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.PropertyBatchLens" href="#Kaleido.PropertyBatchLens"><code>Kaleido.PropertyBatchLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PropertyBatchLens(names)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; lens = PropertyBatchLens(:a, :b, :c);

julia&gt; get((a=1, b=2, c=3, d=4), lens)
(a = 1, b = 2, c = 3)

julia&gt; set((a=1, b=2, c=3, d=4), lens, (a=10, b=20, c=30))
(a = 10, b = 20, c = 30, d = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/batchlenses.jl#LL1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.KeyBatchLens" href="#Kaleido.KeyBatchLens"><code>Kaleido.KeyBatchLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KeyBatchLens(names)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; lens = KeyBatchLens(:a, :b, :c);

julia&gt; get((a=1, b=2, c=3, d=4), lens)
(a = 1, b = 2, c = 3)

julia&gt; set((a=1, b=2, c=3, d=4), lens, Dict(:a=&gt;10, :b=&gt;20, :c=&gt;30))
(a = 10, b = 20, c = 30, d = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/batchlenses.jl#LL19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.IndexBatchLens" href="#Kaleido.IndexBatchLens"><code>Kaleido.IndexBatchLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexBatchLens(names)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; lens = IndexBatchLens(:a, :b, :c);

julia&gt; get((a=1, b=2, c=3, d=4), lens)
(1, 2, 3)

julia&gt; set((a=1, b=2, c=3, d=4), lens, (10, 20, 30))
(a = 10, b = 20, c = 30, d = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/batchlenses.jl#LL37-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.FlatLens" href="#Kaleido.FlatLens"><code>Kaleido.FlatLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlatLens(N₁, N₂, ..., Nₙ)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; l = MultiLens((
           (@lens _.x) ∘ IndexBatchLens(:a, :b, :c),
           (@lens _.y) ∘ IndexBatchLens(:d, :e),
       )) ∘ FlatLens(3, 2);

julia&gt; get((x=(a=1, b=2, c=3), y=(d=4, e=5)), l)
(1, 2, 3, 4, 5)

julia&gt; set((x=(a=1, b=2, c=3), y=(d=4, e=5)), l, (10, 20, 30, 40, 50))
(x = (a = 10, b = 20, c = 30), y = (d = 40, e = 50))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/flatlens.jl#LL1-L19">source</a></section></article><h2 id="Bijective-transformations-as-lenses"><a class="docs-heading-anchor" href="#Bijective-transformations-as-lenses">Bijective transformations as lenses</a><a id="Bijective-transformations-as-lenses-1"></a><a class="docs-heading-anchor-permalink" href="#Bijective-transformations-as-lenses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Kaleido.converting" href="#Kaleido.converting"><code>Kaleido.converting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">converting(; fromfield, tofield) :: Lens</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; halve(x) = x / 2;

julia&gt; double(x) = 2x;

julia&gt; l = (@lens _.y[2]) ∘ converting(fromfield = halve, tofield = double)
(@lens _.y[2]) ∘ (←double|halve→)

julia&gt; obj = (x=0, y=(1, 2, 3));

julia&gt; @assert get(obj, l) == 1.0 == 2/2

julia&gt; set(obj, l, 0.5)
(x = 0, y = (1, 1.0, 3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.setting" href="#Kaleido.setting"><code>Kaleido.setting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setting(xf::TransformVariables.AbstractTransform) :: Lens</code></pre><p>Lens to set value transformed by <code>xf</code> (and get value via the inverse transformation).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido, TransformVariables

julia&gt; l = (@lens _.y[2]) ∘ setting(as𝕀)
(@lens _.y[2]) ∘ (←|as𝕀→)

julia&gt; obj = (x=0, y=(1, 0.5, 3));

julia&gt; get(obj, l)
0.0

julia&gt; @assert set(obj, l, Inf).y[2] ≈ 1

julia&gt; @assert set(obj, l, -Inf).y[2] ≈ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.getting" href="#Kaleido.getting"><code>Kaleido.getting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getting(xf::TransformVariables.AbstractTransform) :: Lens</code></pre><p>Lens to get value transformed by <code>xf</code> (and set value via the inverse transformation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.settingasℝ₊" href="#Kaleido.settingasℝ₊"><code>Kaleido.settingasℝ₊</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">settingasℝ₊ :: BijectionLens</code></pre><p>This is a stripped-down version of <code>setting(asℝ₊)</code> that works without TransformVariables.jl.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; l = (@lens _.y[2]) ∘ settingasℝ₊
(@lens _.y[2]) ∘ (←exp|log→)

julia&gt; obj = (x=0, y=(0, 1, 2));

julia&gt; @assert get(obj, l) == 0.0 == log(obj.y[2])

julia&gt; @assert set(obj, l, -1) == (x=0, y=(0, exp(-1), 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL104-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.settingasℝ₋" href="#Kaleido.settingasℝ₋"><code>Kaleido.settingasℝ₋</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">settingasℝ₋ :: BijectionLens</code></pre><p>This is a stripped-down version of <code>setting(asℝ₋)</code> that works without TransformVariables.jl.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; l = (@lens _.y[2]) ∘ settingasℝ₋
(@lens _.y[2]) ∘ (←negexp|logneg→)

julia&gt; obj = (x=0, y=(0, -1, 2));

julia&gt; @assert get(obj, l) == 0.0 == log(-obj.y[2])

julia&gt; @assert set(obj, l, 1) == (x=0, y=(0, -exp(1), 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL127-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.settingas𝕀" href="#Kaleido.settingas𝕀"><code>Kaleido.settingas𝕀</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">settingas𝕀 :: BijectionLens</code></pre><p>This is a stripped-down version of <code>setting(as𝕀)</code> that works without TransformVariables.jl.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; l = (@lens _.y[2]) ∘ settingas𝕀
(@lens _.y[2]) ∘ (←logistic|logit→)

julia&gt; obj = (x=0, y=(0, 0.5, 2));

julia&gt; get(obj, l)
0.0

julia&gt; @assert set(obj, l, Inf).y[2] ≈ 1

julia&gt; @assert set(obj, l, -Inf).y[2] ≈ 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/bijection.jl#LL150-L172">source</a></section></article><h2 id="Misc-lenses"><a class="docs-heading-anchor" href="#Misc-lenses">Misc lenses</a><a id="Misc-lenses-1"></a><a class="docs-heading-anchor-permalink" href="#Misc-lenses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Kaleido.getting-Tuple{Any}" href="#Kaleido.getting-Tuple{Any}"><code>Kaleido.getting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getting(f) :: Lens</code></pre><p>Apply a callable <code>f</code> (typically a type constructor) before getting the value; i.e.,</p><pre><code class="nohighlight hljs">get(obj, lens ∘ getting(f)) == f(get(obj, lens))</code></pre><p>This is useful for, e.g., getting a tuple as a <code>StaticVector</code> and converting it back to a tuple when setting.</p><p>Note that <code>getting</code> requires some properties for <code>f</code> and the values stored in the &quot;field.&quot;  See the details below.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield, StaticArrays

julia&gt; obj = (x = ((0, 1, 2), &quot;A&quot;), y = &quot;B&quot;);

julia&gt; lens = (@lens _.x[1]) ∘ getting(SVector)
(@lens _.x[1]) ∘ (←|SVector{S, T} where {S, T}→)

julia&gt; get(obj, lens) === SVector(obj.x[1])
true

julia&gt; set(obj, lens, SVector(3, 4, 5))
(x = ((3, 4, 5), &quot;A&quot;), y = &quot;B&quot;)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield, StaticArrays

julia&gt; obj = (x = ((a = 0, b = 1, c = 2), &quot;A&quot;), y = &quot;B&quot;);

julia&gt; lens = (@lens _.x[1]) ∘ getting(Base.splat(SVector))
(@lens _.x[1]) ∘ (←|#60→)

julia&gt; get(obj, lens) === SVector(obj.x[1]...)
true

julia&gt; set(obj, lens, SVector(3, 4, 5))
(x = ((a = 3, b = 4, c = 5), &quot;A&quot;), y = &quot;B&quot;)</code></pre><p><strong>Details</strong></p><p>The lens created by <code>getting(f)</code> relies on that:</p><ul><li><p>The output value <code>y = f(x)</code> can be converted back to the original value <code>x</code> by <code>C(y)</code> where <code>C</code> is a constructor of <code>x</code>; i.e., for any <code>x</code> that could be retrieved from the object through this lens,</p><pre><code class="nohighlight hljs">C(f(x)) == x</code></pre></li><li><p>The conversion in the reverse direction also holds; i.e., for any <code>y</code> that could be stored into the object through this lens,</p><pre><code class="nohighlight hljs">f(C(y)) == y</code></pre></li></ul><p>The constructor <code>C</code> can be controlled by defining <code>Setfield.constructor_of</code> for custom types of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/converterlens.jl#LL1-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.constraining" href="#Kaleido.constraining"><code>Kaleido.constraining</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constraining(f; onget=true, onset=true)</code></pre><p>Create a lens to impose constraints by a callable <code>f</code>.</p><ul><li><p>The callable <code>f</code> must be idempotent; i.e., <code>f ∘ f = f</code>.</p></li><li><p>If the original object already satisfies the constraint (i.e. <code>f(obj) == obj</code>), <code>onget=false</code> can be passed safely to skip calling <code>f</code> during <code>get</code>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield

julia&gt; obj = (a = 1, b = 1);

julia&gt; constraint = constraining() do obj
           @set obj.b = obj.a
       end
constraining(#1)

julia&gt; lens = constraint ∘ @lens _.a
constraining(#1) ∘ (@lens _.a)

julia&gt; get(obj, lens)
1

julia&gt; set(obj, lens, 2)
(a = 2, b = 2)</code></pre><p><code>constraining</code> is useful when combined with <a href="#Kaleido.@batchlens"><code>@batchlens</code></a> or <a href="#Kaleido.MultiLens"><code>MultiLens</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Kaleido, Setfield

julia&gt; obj = (a = 1, b = 2, c = 3);

julia&gt; constraint = constraining() do obj
           @set obj.c = obj.a + obj.b
       end;

julia&gt; lens = constraint ∘ MultiLens((
           (@lens _.a),
           (@lens _.b),
       ));

julia&gt; get(obj, lens)
(1, 2)

julia&gt; set(obj, lens, (100, 20))
(a = 100, b = 20, c = 120)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/constraininglens.jl#LL1-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.FLens" href="#Kaleido.FLens"><code>Kaleido.FLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FLens(functor_based_lens) :: Lens</code></pre><p><code>FLens</code> provides an alternative (&quot;isomorphic&quot;) way to create a <code>Lens</code>. It is useful for accessing dynamically determined &quot;field&quot; such as the last item in the linked list.</p><p>(Note: it&#39;s probably better to look at Examples first.)</p><p><code>FLens</code> converts <code>functor_based_lens</code> (a two-argument callable) to the <code>Lens</code> defined in <code>Setfield</code>.  The callable <code>functor_based_lens</code> accepts the following two arguments:</p><ol><li><p><code>setter</code>: a one-argument callable that accepts a value in the &quot;field&quot; and return an object that can be passed to the second argument of <code>Kaleido.fmap</code>.</p></li><li><p><code>obj</code>: an object whose &quot;field&quot; is accessed.</p></li></ol><p><em>Informally</em> the signature of the functions appeared above may be written as</p><pre><code class="language-julia hljs">FLens(functor_based_lens) :: Lens
functor_based_lens(setter, obj)
setter(field::A) :: F{A} where {F &lt;: Functor}
fmap(f, ::F{A}) :: F{B} where {F &lt;: Functor}
f(field::A) :: B</code></pre><p>(note: there is no <code>Functor</code> in actual code)</p><p><strong>Examples</strong></p><p>Here is an implementation of <code>@lens _[1]</code> using <code>FLens</code></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield

julia&gt; using Kaleido: FLens, fmap

julia&gt; fst = FLens((f, obj) -&gt; fmap(x -&gt; (x, obj[2:end]...), f(obj[1])));

julia&gt; get((1, 2, 3), fst)
1

julia&gt; set((1, 2, 3), fst, 100)
(100, 2, 3)</code></pre><p>A typical <code>FLens</code> usage has the form</p><pre><code class="language-julia hljs">FLens((f, obj) -&gt; fmap(x -&gt; SET(obj, x), f(GET(obj))))</code></pre><p>where</p><ul><li><code>SET(obj, x)</code> sets the &quot;field&quot; of the <code>obj</code> to the value <code>x</code>.</li><li><code>GET(obj)</code> gets the value of the &quot;field.&quot;</li></ul><p>What <code>GET</code> and <code>SET</code> does may look like similar to <code>Setfield.get</code> and <code>Setfield.set</code>.  In fact, any lens can be converted into <code>FLens</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield

julia&gt; using Kaleido: FLens, fmap

julia&gt; asflens(lens::Lens) =
           FLens((f, obj) -&gt; fmap(x -&gt; set(obj, lens, x), f(get(obj, lens))));

julia&gt; dot_a = asflens(@lens _.a);

julia&gt; get((a=1, b=2), dot_a)
1

julia&gt; set((a=1, b=2), dot_a, 100)
(a = 100, b = 2)</code></pre><p>If <code>FLens</code> is &quot;isomorphic&quot; to usual <code>Lens</code>, why not directly define <code>Setfield.get</code> and <code>Setfield.set</code>?  (They are easier to understand.)</p><p>This is because <code>FLens</code> is useful if the &quot;field&quot; of interest can only be dynamically determined.  For example, a lens to the last item of linked lists can be defined as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield

julia&gt; using Kaleido: FLens, fmap

julia&gt; struct Cons{T, S}
           car::T
           cdr::S
       end

julia&gt; last_impl(f, list, g) =
           if list.cdr === nothing
               h = x -&gt; g(Cons(x, nothing))
               fmap(h, f(list.car))
           else
               h = x -&gt; g(Cons(list.car, x))
               last_impl(f, list.cdr, h)
           end;

julia&gt; lst = FLens((f, list) -&gt; last_impl(f, list, identity));

julia&gt; list = Cons(1, Cons(2, Cons(3, nothing)));

julia&gt; get(list, lst)
3

julia&gt; set(list, lst, :last) === Cons(1, Cons(2, Cons(:last, nothing)))
true</code></pre><p>Notice that <code>last_impl</code> dynamically builds the closure <code>h</code> that is passed as the first argument of <code>fmap</code>.  Although it is possible to implement the same lens by directly defining <code>Setfield.get</code> and <code>Setfield.set</code>, those two functions would have duplicated code for recursing into the last item.</p><p>Another (marginal?) benefit is that <code>FLens</code> can be more efficient when using <code>modify</code>.  This is because <code>FLens</code> can do <code>modify</code> in one recursion into the &quot;field&quot; while two recursions are necessary with <code>get</code> and <code>set</code>.  It can be relevant especially with complex object and lens where <code>get</code> and <code>set</code> used in <code>modify</code> cannot be inlined (e.g., due to type instability).</p><p><code>FLens</code> can also be used for imposing some constraints in the fields. However, it may be better to use <a href="#Kaleido.constraining"><code>constraining</code></a> for this purpose.</p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield

julia&gt; using Kaleido: FLens, fmap

julia&gt; fstsnd = FLens((f, obj) -&gt; fmap(
           x -&gt; (x, x, obj[3:end]...),
           begin
               @assert obj[1] == obj[2]
               f(obj[1])
           end,
       ));

julia&gt; get((1, 1, 2), fstsnd)
1

julia&gt; set((1, 1, 2), fstsnd, 100)
(100, 100, 2)</code></pre><p><strong>Side notes</strong></p><p><code>FLens</code> mimics the formalism used in <a href="http://hackage.haskell.org/package/lens">the lens in Haskell</a>. For an introduction to lens, the talk <a href="https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation">Lenses: compositional data access and manipulation</a> by Simon Peyton Jones is highly recommended.  In this talk, a simplified form of lens uses in Haskell is explained in details:</p><pre><code class="language-haskell hljs">type Lens&#39; s a = forall f. Functor f
                        =&gt; (a -&gt; f a) -&gt; s -&gt; f s</code></pre><p>Informally, this type synonym maps to the signature of <code>FLens</code>:</p><pre><code class="language-julia hljs">FLens(((::A -&gt; ::F{A}), ::S) -&gt; ::F{S} where F &lt;: Functor) :: Lens</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/functorlens.jl#LL1-L175">source</a></section></article><h2 id="Setters"><a class="docs-heading-anchor" href="#Setters">Setters</a><a id="Setters-1"></a><a class="docs-heading-anchor-permalink" href="#Setters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Kaleido.nullsetter" href="#Kaleido.nullsetter"><code>Kaleido.nullsetter</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">nullsetter :: Setter</code></pre><p>A setter that does nothing; i.e., <code>set(x, nullsetter, y) === x</code> for any <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; set(1, nullsetter, 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/setters.jl#LL8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Kaleido.ToField" href="#Kaleido.ToField"><code>Kaleido.ToField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ToField(f) :: Setter</code></pre><p>Apply <code>f</code> when setting.  Use <code>x -&gt; get(x, f)</code> if <code>f</code> is a <code>Lens</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; setter = (@lens _.x) ∘ ToField(@lens _.a)
(@lens _.x) ∘ (←(@lens _.a)|❌→)

julia&gt; set((x = 1, y = 2), setter, (a = 10, b = 20))
(x = 10, y = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/setters.jl#LL27-L42">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Kaleido.prettylens" href="#Kaleido.prettylens"><code>Kaleido.prettylens</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prettylens(lens::Lens; sprint_kwargs...) :: String
prettylens(io::IO, lens::Lens)</code></pre><p>Print or return more compact and easier-to-read string representation of <code>lens</code> than <code>show</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Setfield, Kaleido

julia&gt; prettylens(
           (@lens _.a) ∘ MultiLens((
               (@lens last(_)),
               (@lens _[:c].d) ∘ settingasℝ₊,
           ));
           context = :compact =&gt; true,
       )
&quot;◻.a∘〈last(◻),◻[:c].d∘(←exp|log→)〉&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tkf/Kaleido.jl/blob/104c2daaa3ef886bd1e2f451a298484ca8f494ac/src/prettylens.jl#LL1-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Wednesday 27 April 2022 09:43">Wednesday 27 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
